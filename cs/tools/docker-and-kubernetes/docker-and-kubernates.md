# Docker and Kubernetes: The Complete Guide
* Udemy
* Stephen Grider

# Install Docker on Mac
* sign up for docker hub
  * jexxx009

# What is Docker?
* Docker Client(CLI), Docker Server and Docker Hub
  ```
  docker run hello-world
  ```
  * docker run = docker create + docker start.
    * docker create command creates a container.
    * docker start starts a container.    
    * when you run the command above for the first time, docker client asks docker server for hello-world image. (note that       docker client and docker server is at local)
  * docker server looks at image cache where it realizes image cache doesn't have the image.
  * docker server downloads hello-world image from docker hub
* Image
  * a file that describes a program configuration and startup commands; FS snapshot + startup commands; (FS = file system)
  * = program configurtation (easy understand)
* Container
  * a namespaced resources that runs a process(s). (partition of resources)
    * Namespace (Linux Namespace) is a feature of Linux kernel to partition resources for processes.
  * = resource partition (easy understand)
* Container loads image when running it.
* Image creates a container and container can create an image.

# Docker containers (section 2)
* busybox is a lite-weight linux program.
  ```
  docker run busy-box ls
  ```
* lists currently running containers.  
  ```
  docker ps
  ```
* lists currently existing containers. (containers can exist without being started = stop)  
  ```
  docker ps --all
  ```
* returns a container id (for example, ab92295e9859a86ff59d7a43cd7d4294151e37740465d64c50b3e913c7e22dd5)  
  ```
  docker create hello-world
  ```
* docker start will simply start a container, and -a flag will print out logs generated from the container.  
  ```
  docker start ab92295e9859a86ff59d7a43cd7d4294151e37740465d64c50b3e913c7e22dd5
  docker start -a ab92295e9859a86ff59d7a43cd7d4294151e37740465d64c50b3e913c7e22dd5
  ```
* you can start a previously created container with its container id.
  ```
  docker run busybox echo hi there
  docker ps --all 
  (assume ddf1b6421e72 is the busybox container id generated by command above)
  docker start ddf1b6421e72
  docker start -a ddf1b6421e72
  ```
* this command will fail because you can not replace the startup commands of a previously created container.
  * you will see an error message: 'you cannot start and attach multiple containers at once'
  ```
  docker start -a ddf1b6421e72 bye there
  ```
* this command will delete some resources including image-cache and stopped containers.
  ```
  docker system prune
  ```
* docker logs doesn't actually start a container. It will simply bring out the any messages generated from having started a     container. note that 'docker start e37740465d64c50b3e913c7e22dd5' itself won't generate a message to us.
  ```
  docker create busybox echo hi there -->  e37740465d64c50b3e913c7e22dd5
  docker start e37740465d64c50b3e913c7e22dd5  -->  k37740465d64c50b3e913c7e22aa6
  docker logs k37740465d64c50b3e913c7e22aa6 --> hi there
  ```
* docker stop command will send SIGTERM signal to a container to stop the container itself. (allows clean up itself)
* docker kill command will send SIGKILL signal to a container to kill the container process right awaw.
  ```
  docker stop e37740465d64c50b3e913c7e22dd5
  docker kill e37740465d64c50b3e913c7e22dd5
  ```
* redis is an in-memory database program. when you run redis, you can use redis-cli to interact with redis database.
  redis-cli is a command line tool for redis operations. however, you can't directly interact with the container that you   
  just created for running redis. you need to get inside the container that is running and execute a second command for   
  redis-cli operations.
  ```
  docker run redis
  ```
* exec allows you to execute additional commands inside the container.
  * docker exec {container-id} {command you want to execute inside the container you specified}
  * -it = --interactive + --pseudo-TTY
  * -i: attach terminal STDIN of local to STDIN of container
  * -t: format the whole thing using pseudotty(pseudo terminal)
  ```
  (assume 06c404248d22 is the container-id of docker redis)
  docker exec 06c404248d22 redis-cli
  docker exec -it 06c404248d22 redis-cli
  ```
  ```
  (assume 06c404248d44 is the container-id of docker redis)
  docker exec -it 06c404248d44 sh
  ```

# Docker Custom Image
* Let's create an image that runs redis server.
* Create a Dockerfile in redis-image directory 
  * base image works like an OS when running your image. (initial starting point to your image)
  * alpine has apk included. (apk is a apache package manager)
  * $redis-server will be executed as a terminal command when this image starts

  * alpine base image is downloaded ---> it is used to execute commands specified by RUN ---> 
  ```
  # User an existing docker image as a base image.
  FROM alpine

  # Download and install dependencies.
  RUN apk add --update redis

  # Tell what to execute when a container starts. -> returns an id of an image generated.
  CMD ["redis-server"]
  ```
  * FROM A: download a base image A
  * RUN B: create a temporary container with 'FROM A' image and execute B on top of it, and generate the final result as an     image.
  * CMD C: execute C on a container built with image generated from 'RUN B'
* When you run same 'RUN B' commands after its first use, Docker knows to use cached image generating a same new one.
* You can tag an image by following syntax
 '''
 docker build -t id/project:version .
 '''
 * -t: TAG flag (note that -t flag used with docker run is a pseudo-terminal flag)
 * build at current directory specified by .
* You can create an image out of a container. (assuming 39075441dw1 is a container id)
 ```
 docker commit -c 'CMD["redis-server"]' 3907544dw1
 ```
# Creating a Docker Project
* lets create a Node.js project with index.js and package.json.
* create a Dockerfile in the same directory
  * which base image is proper for your project?
    * go check at hub.docker.com (https://hub.docker.com/_/node/)
    * let's use node:alpine is available
  * index.js and package.json are not pointed by npm
    * COPY {from directory} {to directory}
    * you can split copy operations to maximize the use of cached images.
      * command below will execute npm install everytime there is any change in ./
      ```
      COPY ./ ./
      RUN npm install
      ```
      * However, we expect that npm install should be executed when there is a change in package.json file that manages npm         dependencies. you can write docker commands like below to execute npm install when there is a change in package.json           only.
      ```
      COPY ./package.json ./
      RUN npm install
      COPY ./ ./
      ```

  * node.js is started in container, and its port mapping is happending inside the container.  
    * docker run -p {local-port}:{container-port} {image}
    * it maps incoming request to local-port to container-port inside the container built with the image specified.
  * you can make working directory where you can isolate project related works with WORKDIR command
  ```
  # Specify a base image
  FROM alpine

  # Specify directory to put everything inside the container
  # 'workdir' is like 'mkdir & cd' within the container
  WORKDIR /usr/app

  # Install dependencies
  COPY ./package.json ./
  RUN npm Install
  COPY ./ ./

  # Default command
  CMD ["npm", "start"]
  ```
* build/tag a docker image from Dockerfile, and start it. check the project at localhost:8080
  ```
  docker build -t jexxx009/simpleweb . # if you don't specify docker tag version, it is latest is by default.
  docker run -p 8080:8080 jexxx009/simpleweb
  ```
* you can specify terminal command to execute like this
  ```
  docker run -it jexxx009/simpleweb {terminal command}
  docker run -it jexxx009/sinpleweb ls
  docker run -it jexxx009/sinpleweb sh  (sh means execute shell)
  ```
# Creating a visitor counting Docker Project
* Node.js project will need a database to store visior counts. Redis will take care of this part. Then how do we point Redis     project from Node.js project?
* You can write docker commands in docker-compose.yml to automate build statements as below. Docker compose will take           care of networking betweeen containers. For example, redis-server and node-app containers below will have free access to       each other.
  * docker-compose.yml specifies communications between containers.
     ```
     version: '3'
     services:
         redis-server:
             restart: always     (this is a restart policy. If it crashes, restart it)
             image: 'redis'
         node-app:
             restart: always     (this is a restart policy. If it crashes, restart it)
             build: .
             ports: 
                 - "4001:8081"
     ```
  * index.js specifies client host url as 'redis-server'. This is a url to redis app which is made available by docker             compose.
    ```
    const express = require('express');
    const redis = require('redis');

    const app = express();
    const client = redis.createClient({
      host: 'redis-server'
    });
    client.set('visits', 0);

    app.get('/', (req, res) => {
      client.get('visits', (err, visits) => {
        res.send('Number of visits is ' + visits);
        client.set('visits', parseInt(visits) + 1);
      });
    });

    app.listen(8081, () => {
      console.log('Listening on port 8081');
    });
    ```
* docker compose statements
  ```
  docker-compose up           (run docker project with images; if images doesn't exist generate images)
  docker-compuse up --build   (build docker images from scratch and run them)
  docker-compose up -d        (run docker project in background; so that you can use terminal)
  ```

# Docker & Production
* Application Development workflow
  * Development -> Testing -> Deployment
* Production plan
  * Development
    * work at feature branch
    * create a PR to master branch
    * code pushed to Travis-CI
  * Testing
    * run tests
    * test passed
    * merge a PR to master branch
    * code pushed to Travis-CI
    * run tests 
    * test passed
  * Deploymnet
    * app deployed to AWS Elastic Beanstalk
* Create a React project
  * starting a React project with create-react-app tool
    ```
    npm install -g create-react-app
    create-react-app frontend
    ```
  * npm commands
    ```
    npm run start   # starts up a development server
    npm run test    # run tests associated with the project
    npm run build   # build production version ---> files built can be found at build/static.
    ```
  * It is reasonable to keep two docker files. One for development the other for production.
  * Development
    * Dockerfile.dev
    ```
    FROM node:alpine

    WORKDIR '/app'

    COPY package.json
    RUN npm install

    COPY . .

    CMD ["npm", "run", "start"]
    ```
    * docker build with -f -> specify Dockerfile you want to use
    ```
    docker build -f Dockerfile.dev .  (put . in the end)
    ```
    * map port to port
    ```
    docker run -p 3000:3000 e9e31d0bf073
    ```
